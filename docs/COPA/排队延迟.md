

核心公式非常简单：

**排队延迟 (Queuing Delay) = 当前RTT (Standing RTT) - 基础RTT (Minimum RTT)**

下面我们来分解这个公式里的两个关键概念：



### 1. 基础RTT (Minimum RTT / `min_rtt`)

- **定义**：这是网络路径的**固有传播延迟**。你可以把它想象成在一条完全没有拥堵、畅通无阻的“高速公路”上，一个数据包从发送方到接收方再返回所需的最短时间。这个值理论上只取决于物理距离、线路传输速度等固定因素。
- **如何获取**：Copa会持续监控所有测量到的RTT值，并记录下自连接开始以来所观察到的**历史最小值**。这个最小值就被当作是`min_rtt`。
- **关键作用**：它为延迟计算提供了一个稳定的“基准线”或“零点”。任何超过这个基准的延迟，Copa都认为是由网络中的排队造成的。



### 2. 当前RTT (Standing RTT / `standing_rtt`)

- **定义**：这不是指单次测量的瞬时RTT，因为瞬时值波动可能很大。`standing_rtt` 是一个**近期的、平滑化的RTT平均值**。它代表了当前网络状况下，数据包往返的“站立”或“典型”时间。
- **如何获取**：Copa会维护一个时间窗口内（例如，过去几秒或几十个RTT周期）的RTT样本。`standing_rtt` 通常是这个窗口内所有RTT样本的**平均值或中位数**。采用平均值或中位数可以滤除单个数据包的异常抖动，得到一个更稳定的当前延迟评估。
- **关键作用**：它反映了包含了**传播延迟 + 当前排队延迟**的总延迟。



### 计算过程总结

结合以上两点，Copa的计算流程如下：

1. **持续测量**：在数据传输过程中，Copa为每个或每组被确认（ACKed）的数据包测量其RTT。
2. **更新min_rtt**：如果新测量的RTT值低于历史记录的`min_rtt`，就更新`min_rtt`。这个值在连接初期会很快确定下来，之后除非网络路径发生重大变化，否则基本保持不变。
3. **更新standing_rtt**：将新测量的RTT样本放入一个队列或窗口中，并重新计算这个窗口内样本的平均值，从而得到最新的`standing_rtt`。
4. **计算排队延迟**：执行减法操作 `standing_rtt - min_rtt`。结果就是Copa推断出的、由数据包在瓶颈路由器缓冲区中等待所花费的时间。

**举个例子：**

- 经过一段时间的测量，Copa发现最快的RTT是 **20ms**。于是 `min_rtt = 20ms`。
- 在接下来的某个时刻，网络开始有些拥堵，最近几十个数据包的平均RTT上升到了 **35ms**。于是 `standing_rtt = 35ms`。
- 此时，Copa计算出的排队延迟就是：`35ms - 20ms = 15ms`。

这个 `15ms` 就是Copa进行拥塞控制决策的核心依据。它会拿这个值和预设的目标排队延迟（由参数 `δ` 决定）进行比较，从而调整自己的发送速率。