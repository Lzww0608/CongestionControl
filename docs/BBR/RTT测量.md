### 1. RTT (往返时间) 是如何测量的？

RTT的测量就像是寄一封挂信并开启一个秒表。

1. **开始计时**：当发送方（Sender）发送一个TCP数据包（Packet）时，它会记录下当前的时间点，我们称之为 `T_send`。
2. **对方回应**：接收方（Receiver）收到这个数据包后，会发送一个确认包（ACK）回来。
3. **停止计时**：当发送方收到这个对应的ACK时，它再次记录当前的时间点，我们称之为 `T_ack`。
4. **计算差值**：`RTT = T_ack - T_send`。这个差值就是数据包“走一个来回”所花的时间。

**现代TCP系统中的精确测量方法：TCP时间戳选项 (TCP Timestamps Option)**

上面的基本原理是对的，但在实际网络中，如果一个包丢了并被重传，发送方就很难判断收到的ACK是对应第一次发送的包还是重传的包。为了解决这个“歧义”问题，现代TCP协议普遍使用了一个更精确的机制——**TCP时间戳选项 (RFC 7323)**。

- **发送时**：发送方在发送数据包的TCP头部选项里，放入一个自己的当前时间戳，称为 `TSval` (Timestamp Value)。
- **接收并回显**：接收方收到数据包后，当它发送ACK回来时，会把收到的`TSval`原封不动地复制到ACK包的另一个时间戳字段里，称为 `TSecr` (Timestamp Echo Reply)。
- **计算RTT**：发送方收到这个ACK后，用**当前的系统时间**减去ACK包里的 `TSecr` 值，就能得到一个非常精确的RTT样本。
  - `RTT = Current_Time - TSecr`

这个方法非常巧妙，因为它不受重传的影响，能为每个ACK都提供一个准确的RTT测量值，这也是BBR等现代拥塞控制算法能够精确工作的基础。

------



### 2. "ACK确认的数据量" 每次都是不同的吗？

**是的，绝大多数情况下，每次ACK确认的数据量是不同的，而且是动态变化的。**

你提出的公式 `速率 = 这次ACK确认的数据量 / 测量到的RTT` 正是BBR算法估算带宽的核心。理解“ACK确认的数据量”为什么会变化，是理解TCP效率的关键。主要原因有两个：



#### (1) 延迟确认 (Delayed ACKs)

这是最主要的原因。TCP协议为了效率，并**不会**为收到的每一个数据包都立刻发送一个独立的ACK。这样做会产生大量的、只包含确认信息的小数据包，浪费网络带宽。

取而代之的是**延迟确认**机制：

- 当接收方收到一个数据包后，它会启动一个短暂的计时器（例如200毫秒）。
- 它会**等待**一小段时间，看看是否能“攒到”更多的数据包一起确认，或者看看自己有没有数据要发给对方，可以把ACK“捎带”在数据包里一起发出去。

**举个例子：**

1. 发送方连续发送了3个数据包，每个大小为1500字节。
   - Packet 1 (Seq 1-1500)
   - Packet 2 (Seq 1501-3000)
   - Packet 3 (Seq 3001-4500)
2. 接收方收到了Packet 1，启动了Delayed ACK计时器。
3. 在计时器到期前，它又收到了Packet 2。
4. 此时，接收方决定发送一个ACK。因为TCP的ACK是**累积确认 (Cumulative ACKs)**的，这个ACK会说：“我已经收到了所有到3000字节为止的数据”。
5. 发送方收到这个ACK后，它计算出“这次ACK确认的数据量”是 **3000字节** (Packet 1 + Packet 2)，而不是1500字节。
6. 可能下一次，网络有些抖动，接收方只收到了Packet 3，然后计时器就到期了，于是它只发送了对Packet 3的确认。这次发送方收到的ACK确认的数据量就是 **1500字节**。



#### (2) 丢包和乱序 (Packet Loss and Reordering)

网络不是完美的。如果中间某个数据包丢失了，也会导致ACK确认的数据量发生剧烈变化。

- **场景**：发送方发了1、2、3、4、5号包，但2号包丢了。
- **接收方行为**：接收方收到1号包，ACK 1。然后收到3号包，发现2号没了，它会再次发送对1号包的ACK（这叫重复ACK），表示“我还在等2号包”。它收到4号、5号包也是如此。
- **发送方行为**：发送方重传2号包。
- **最终确认**：当接收方终于收到2号包后，它现在手里已经有了1、2、3、4、5号所有包。它会立刻发送一个**大的确认ACK**，直接确认到5号包的结尾。
- **结果**：发送方会收到一个ACK，这个ACK一次性确认了2、3、4、5号包的所有数据量，这是一个非常大的值。



## 实例分析

假设网络真实单向延迟是 25ms，所以真实的 `RTprop` 是 50ms。

1. **发送方 (Sender) 的动作**
   - 在 `T=100ms` 时，发送 **Packet 1**。TCP头部放入时间戳 `TSval = 100`。
   - 在 `T=101ms` 时，发送 **Packet 2**。TCP头部放入时间戳 `TSval = 101`。
   - 在 `T=102ms` 时，发送 **Packet 3**。TCP头部放入时间戳 `TSval = 102`。
2. **接收方 (Receiver) 的动作**
   - 在 `T=125ms` 时，收到 Packet 1。它决定启动**延迟确认**，等待一下。
   - 在 `T=126ms` 时，收到 Packet 2。继续等待。
   - 在 `T=127ms` 时，收到 Packet 3。此时它决定不能再等了，必须发送一个ACK。
3. **接收方构建 ACK 包（这是最关键的一步！）**
   - **确认号 (Ack Number)**：它会设置确认号为 Packet 3 之后期望的序列号，这是一个**累积确认**，告诉发送方“1、2、3号包我都收到了”。
   - **时间戳回显 (Timestamp Echo Reply - TSecr)**：它会把**它收到的最后一个数据包 (Packet 3) 的时间戳** `TSval = 102` 复制到ACK的 `TSecr` 字段中。**它不会用Packet 1的 TSval=100！**
4. **发送方 (Sender) 收到 ACK 并计算 RTT**
   - 在 `T=152ms` 时，发送方收到了这个累积确认ACK。
   - 它查看ACK中的 `TSecr` 字段，值为 `102`。
   - 它用当前时间减去回显的时间戳来计算RTT： `RTT_sample = Current_Time - TSecr` `RTT_sample = 152ms - 102ms = 50ms`



### 结论与分析

- **测量结果**：发送方得到的RTT测量样本是 **50ms**，这精确地反映了 **Packet 3** 的往返时间，完全符合我们假设的真实网络延迟。
- **Packet 1 和 Packet 2 怎么样了？**：我们**没有**得到 Packet 1 和 Packet 2 的独立RTT测量值。它们的安全到达被确认了，但它们的计时信息被“跳过”了。发送方知道它们到了，但不知道它们具体花了多长时间。
- **为什么这是个好设计？**：这个设计的取舍非常明智。它牺牲了RTT采样的**数量**（我们没有为每个包都获得RTT），但保证了我们获得的每一个RTT采样的**质量**（准确性）。

对于BBR这样的算法来说，拥有**准确的**RTT样本远比拥有**大量的、被污染的**RTT样本要重要得多。一个虚高的RTT样本会导致`RTprop`计算错误，进而导致BDP（带宽时延积）计算错误，整个拥塞控制模型就会崩溃。

